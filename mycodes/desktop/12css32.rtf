{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Consolas;}}
{\colortbl\red0\green128\blue0;\red0\green0\blue0;\red255\green0\blue0;\red128\green0\blue128;\red0\green0\blue255;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title 12css32.rtf}}

\deflang1033\pard\plain\f0\fs22 \cf0 #include<stdio.h>
\par #include<stdlib.h>
\par #define MAX 20
\par \cf1\b typedef\b0  \b struct\b0  Q
\par \cf2\b \{
\par \b0\cf1  \b int\b0  data\cf2\b [\b0\cf1 MAX\cf2\b ];
\par \b0\cf1  \b int\b0  R\cf2\b ,\b0\cf1 F\cf2\b ;
\par \}\b0\cf1 Q\cf2\b ;
\par 
\par \cf1 typedef\b0  \b struct\b0  node
\par \cf2\b \{
\par \b0\cf1  \b struct\b0  node \cf2\b *\b0\cf1 next\cf2\b ;
\par \b0\cf1  \b int\b0  vertex\cf2\b ;
\par \}\b0\cf1 node\cf2\b ;
\par 
\par \cf1 void\b0  enqueue\cf2\b (\b0\cf1 Q \cf2\b *,\cf1 int\cf2 );
\par \cf1 int\b0  dequeue\cf2\b (\b0\cf1 Q \cf2\b *);
\par \cf1 int\b0  empty\cf2\b (\b0\cf1 Q \cf2\b *);
\par \cf1 int\b0  full\cf2\b (\b0\cf1 Q \cf2\b *);
\par \cf1 void\b0  BFS\cf2\b (\cf1 int\cf2 );
\par \cf1 void\b0  readgraph\cf2\b ();\b0\cf1      
\par \b void\b0  insert\cf2\b (\cf1 int\b0  vi\cf2\b ,\cf1 int\b0  vj\cf2\b );\b0\cf1      
\par \b int\b0  visited\cf2\b [\b0\cf1 MAX\cf2\b ];
\par \b0\cf1 node \cf2\b *\b0\cf1 G\cf2\b [\b0\cf3 20\cf2\b ];\b0\cf1   
\par \b int\b0  n\cf2\b ;\b0\cf1                 
\par 
\par \b int\b0  main\cf2\b ()
\par \{
\par \b0\cf1  \b int\b0  i\cf2\b ,\b0\cf1 op\cf2\b ;
\par \b0\cf1  \b do
\par \b0    \cf2\b \{\b0\cf1  printf\cf2\b (\cf4 "\\n\\n1)Create the tree\\n2)BFS\\n3)Quit"\cf2 );
\par \b0\cf1      printf\cf2\b (\cf4 "\\nEnter Your Choice: "\cf2 );
\par \b0\cf1      scanf\cf2\b (\cf4 "%d"\cf2 ,&\b0\cf1 op\cf2\b );
\par \b0\cf1      \b switch\cf2 (\b0\cf1 op\cf2\b )
\par \b0\cf1       \cf2\b \{\b0\cf1  \b case\b0  \cf3 1\cf2\b :\b0\cf1  readgraph\cf2\b ();\cf1 break\cf2 ;
\par \b0\cf1         \b case\b0  \cf3 2\cf2\b :\b0\cf1  printf\cf2\b (\cf4 "\\nStarting Node No. : "\cf2 );
\par \b0\cf1          scanf\cf2\b (\cf4 "%d"\cf2 ,&\b0\cf1 i\cf2\b );
\par \b0\cf1          BFS\cf2\b (\b0\cf1 i\cf2\b );\cf1 break\cf2 ;
\par \b0\cf1         
\par        \cf2\b \}
\par \b0\cf1     \cf2\b \}\cf1 while\cf2 (\b0\cf1 op\cf2\b !=\b0\cf3 3\cf2\b );
\par \b0\cf1     \b return\b0  \cf3 0\cf2\b ;
\par \}
\par 
\par 
\par \cf1 void\b0  BFS\cf2\b (\cf1 int\b0  v\cf2\b )
\par \{
\par \b0\cf1  \b int\b0  w\cf2\b ,\b0\cf1 i\cf2\b ,\b0\cf1 visited\cf2\b [\b0\cf1 MAX\cf2\b ];
\par \b0\cf1  Q q\cf2\b ;
\par 
\par \b0\cf1  node \cf2\b *\b0\cf1 p\cf2\b ;
\par \b0\cf1  q\cf2\b .\b0\cf1 R\cf2\b =\b0\cf1 q\cf2\b .\b0\cf1 F\cf2\b =-\b0\cf3 1\cf2\b ;\b0\cf1              
\par  \b for\cf2 (\b0\cf1 i\cf2\b =\b0\cf3 0\cf2\b ;\b0\cf1 i\cf2\b <\b0\cf1 n\cf2\b ;\b0\cf1 i\cf2\b ++)
\par \b0\cf1   visited\cf2\b [\b0\cf1 i\cf2\b ]=\b0\cf3 0\cf2\b ;
\par \b0\cf1  enqueue\cf2\b (&\b0\cf1 q\cf2\b ,\b0\cf1 v\cf2\b );
\par \b0\cf1  printf\cf2\b (\cf4 "\\nVisit\\t%d"\cf2 ,\b0\cf1 v\cf2\b );
\par \b0\cf1  visited\cf2\b [\b0\cf1 v\cf2\b ]=\b0\cf3 1\cf2\b ;
\par \b0\cf1  \b while\cf2 (!\b0\cf1 empty\cf2\b (&\b0\cf1 q\cf2\b ))
\par \b0\cf1  \cf2\b \{
\par \b0\cf1   v\cf2\b =\b0\cf1 dequeue\cf2\b (&\b0\cf1 q\cf2\b );
\par \b0\cf1   \b for\cf2 (\b0\cf1 p\cf2\b =\b0\cf1 G\cf2\b [\b0\cf1 v\cf2\b ];\b0\cf1 p\cf2\b !=\b0\cf1 NULL\cf2\b ;\b0\cf1 p\cf2\b =\b0\cf1 p\cf2\b ->\b0\cf1 next\cf2\b )
\par \b0\cf1   \cf2\b \{
\par \b0\cf1    w\cf2\b =\b0\cf1 p\cf2\b ->\b0\cf1 vertex\cf2\b ;
\par \b0\cf1    \b if\cf2 (\b0\cf1 visited\cf2\b [\b0\cf1 w\cf2\b ]==\b0\cf3 0\cf2\b )
\par \b0\cf1    \cf2\b \{
\par \b0\cf1     enqueue\cf2\b (&\b0\cf1 q\cf2\b ,\b0\cf1 w\cf2\b );
\par \b0\cf1     visited\cf2\b [\b0\cf1 w\cf2\b ]=\b0\cf3 1\cf2\b ;
\par \b0\cf1     printf\cf2\b (\cf4 "\\nvisit\\t%d"\cf2 ,\b0\cf1 w\cf2\b );
\par \b0\cf1    \cf2\b \}
\par \b0\cf1   \cf2\b \}
\par \b0\cf1  \cf2\b \}
\par \}
\par \cf1 int\b0  empty\cf2\b (\b0\cf1 Q \cf2\b *\b0\cf1 P\cf2\b )
\par \{
\par \b0\cf1  \b if\cf2 (\b0\cf1 P\cf2\b ->\b0\cf1 R\cf2\b ==-\b0\cf3 1\cf2\b )
\par \b0\cf1   \b return\cf2 (\b0\cf3 1\cf2\b );
\par \b0\cf1  \b return\cf2 (\b0\cf3 0\cf2\b );
\par \}
\par 
\par \cf1 int\b0  full\cf2\b (\b0\cf1 Q \cf2\b *\b0\cf1 P\cf2\b )
\par \{
\par \b0\cf1  \b if\cf2 (\b0\cf1 P\cf2\b ->\b0\cf1 R\cf2\b ==\b0\cf1 MAX\cf2\b -\b0\cf3 1\cf2\b )
\par \b0\cf1   \b return\cf2 (\b0\cf3 1\cf2\b );
\par \b0\cf1  \b return\cf2 (\b0\cf3 0\cf2\b );
\par \}
\par 
\par \cf1 void\b0  enqueue\cf2\b (\b0\cf1 Q \cf2\b *\b0\cf1 P\cf2\b ,\cf1 int\b0  x\cf2\b )
\par \{
\par \b0\cf1  \b if\cf2 (\b0\cf1 P\cf2\b ->\b0\cf1 R\cf2\b ==-\b0\cf3 1\cf2\b )
\par \b0\cf1  \cf2\b \{
\par \b0\cf1   P\cf2\b ->\b0\cf1 R\cf2\b =\b0\cf1 P\cf2\b ->\b0\cf1 F\cf2\b =\b0\cf3 0\cf2\b ;
\par \b0\cf1   P\cf2\b ->\b0\cf1 data\cf2\b [\b0\cf1 P\cf2\b ->\b0\cf1 R\cf2\b ]=\b0\cf1 x\cf2\b ;
\par \b0\cf1  \cf2\b \}
\par \b0\cf1  \b else
\par \b0  \cf2\b \{
\par \b0\cf1   P\cf2\b ->\b0\cf1 R\cf2\b =\b0\cf1 P\cf2\b ->\b0\cf1 R\cf2\b +\b0\cf3 1\cf2\b ;
\par \b0\cf1   P\cf2\b ->\b0\cf1 data\cf2\b [\b0\cf1 P\cf2\b ->\b0\cf1 R\cf2\b ]=\b0\cf1 x\cf2\b ;
\par \b0\cf1  \cf2\b \}
\par \}
\par 
\par \cf1 int\b0  dequeue\cf2\b (\b0\cf1 Q \cf2\b *\b0\cf1 P\cf2\b )
\par \{
\par \b0\cf1  \b int\b0  x\cf2\b ;
\par \b0\cf1  x\cf2\b =\b0\cf1 P\cf2\b ->\b0\cf1 data\cf2\b [\b0\cf1 P\cf2\b ->\b0\cf1 F\cf2\b ];
\par \b0\cf1  \b if\cf2 (\b0\cf1 P\cf2\b ->\b0\cf1 R\cf2\b ==\b0\cf1 P\cf2\b ->\b0\cf1 F\cf2\b )
\par \b0\cf1  \cf2\b \{
\par \b0\cf1   P\cf2\b ->\b0\cf1 R\cf2\b =-\b0\cf3 1\cf2\b ;
\par \b0\cf1   P\cf2\b ->\b0\cf1 F\cf2\b =-\b0\cf3 1\cf2\b ;
\par \b0\cf1  \cf2\b \}
\par \b0\cf1  \b else
\par \b0   P\cf2\b ->\b0\cf1 F\cf2\b =\b0\cf1 P\cf2\b ->\b0\cf1 F\cf2\b +\b0\cf3 1\cf2\b ;
\par \b0\cf1  \b return\cf2 (\b0\cf1 x\cf2\b );
\par \}
\par 
\par \cf1 void\b0  readgraph\cf2\b ()
\par \{\b0\cf1   \b int\b0  i\cf2\b ,\b0\cf1 vi\cf2\b ,\b0\cf1 vj\cf2\b ,\b0\cf1 edges\cf2\b ;
\par \b0\cf1  printf\cf2\b (\cf4 "\\nEnter no. of vertices :"\cf2 );
\par \b0\cf1  scanf\cf2\b (\cf4 "%d"\cf2 ,&\b0\cf1 n\cf2\b );
\par \b0\cf1  \b for\cf2 (\b0\cf1 i\cf2\b =\b0\cf3 0\cf2\b ;\b0\cf1 i\cf2\b <\b0\cf1 n\cf2\b ;\b0\cf1 i\cf2\b ++)
\par \b0\cf1   G\cf2\b [\b0\cf1 i\cf2\b ]=\b0\cf1 NULL\cf2\b ;
\par \b0\cf1  printf\cf2\b (\cf4 "\\nEnter no of edges :"\cf2 );
\par \b0\cf1  scanf\cf2\b (\cf4 "%d"\cf2 ,&\b0\cf1 edges\cf2\b );
\par \b0\cf1  \b for\cf2 (\b0\cf1 i\cf2\b =\b0\cf3 0\cf2\b ;\b0\cf1 i\cf2\b <\b0\cf1 edges\cf2\b ;\b0\cf1 i\cf2\b ++)
\par \b0\cf1  \cf2\b \{
\par \b0\cf1   printf\cf2\b (\cf4 "\\nEnter an edge u v separated by space :"\cf2 );
\par \b0\cf1   scanf\cf2\b (\cf4 "%d%d"\cf2 ,&\b0\cf1 vi\cf2\b ,&\b0\cf1 vj\cf2\b );
\par \b0\cf1   insert\cf2\b (\b0\cf1 vi\cf2\b ,\b0\cf1 vj\cf2\b );
\par \b0\cf1   insert\cf2\b (\b0\cf1 vj\cf2\b ,\b0\cf1 vi\cf2\b );
\par \b0\cf1  \cf2\b \}
\par \}
\par 
\par \cf1 void\b0  insert\cf2\b (\cf1 int\b0  vi\cf2\b ,\cf1 int\b0  vj\cf2\b )
\par \{
\par \b0\cf1  node \cf2\b *\b0\cf1 p\cf2\b ,*\b0\cf1 q\cf2\b ;
\par \b0\cf1  
\par  q\cf2\b =(\b0\cf1 node \cf2\b *)\b0\cf1 malloc\cf2\b (\cf1 sizeof\cf2 (\b0\cf1 node\cf2\b ));
\par \b0\cf1  q\cf2\b ->\b0\cf1 vertex\cf2\b =\b0\cf1 vj\cf2\b ;
\par \b0\cf1  q\cf2\b ->\b0\cf1 next\cf2\b =\b0\cf1 NULL\cf2\b ;
\par 
\par \b0\cf1  \b if\cf2 (\b0\cf1 G\cf2\b [\b0\cf1 vi\cf2\b ]==\b0\cf1 NULL\cf2\b )
\par \b0\cf1   G\cf2\b [\b0\cf1 vi\cf2\b ]=\b0\cf1 q\cf2\b ;
\par \b0\cf1  \b else
\par \b0  \cf2\b \{
\par 
\par \b0\cf1   p\cf2\b =\b0\cf1 G\cf2\b [\b0\cf1 vi\cf2\b ];
\par \b0\cf1   \b while\cf2 (\b0\cf1 p\cf2\b ->\b0\cf1 next\cf2\b !=\b0\cf1 NULL\cf2\b )
\par \b0\cf1    p\cf2\b =\b0\cf1 p\cf2\b ->\b0\cf1 next\cf2\b ;
\par \b0\cf1   p\cf2\b ->\b0\cf1 next\cf2\b =\b0\cf1 q\cf2\b ;
\par \b0\cf1  \cf2\b \}
\par \}
\par 
\par }